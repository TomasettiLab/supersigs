---
title: "Using the supersigs package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{supersigs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  comment = "#>"
)
```

```{r setup}
library(supersigs)
```

# Introduction

The `supersigs` package implements the supervised method proposed by *Afsari, et al.* to find signatures ("SuperSigs"). In this vignette, we cover how to preprocess your data and run the method in `supersigs`.

# Preprocessing your data

## Example data

The method uses single-base mutations in exomic data from cancer samples. Specifically, it requires data on every sample's mutations, the positions of those mutations, and the age of all patients. This data can be represented as a list of mutations (e.g. in a VCF file). Below is an example dataset (stored and accessible from the `supersigs` R package).

* `sample_id` is an ID for each sample
* `age` is the age of the patient
* `chromosome` and `position` is the position of the mutation
* `from` is the original nucleotide
* `to` is the mutated nucleotide 

```{r}
print(example_dt)
```

## Transform data

Once you've read in your data, you will need to transform it into a data frame of features that is readable by the `supersigs` package. This involves 2 steps:

1. First, we assume that mutations are the same regardless of the strand on which it occurred. For example, this means that C>A mutations are considered the same as G>T mutations. We will convert all G>T mutations to be denoted as C>A mutations using the named vector `transform_muts_vec`, which is stored and accessible from the `supersigs` R package.

2. Because the features used are built upon trinucleotide features (e.g. A[C>A]T), this will require matching your mutations to a reference genome to identify what the flanking bases of every mutation are. In our example below, we will use the `hg19` reference genome.

Both of these steps are done by the `make_matrix` function from the `supersigs` package. Note that to use the function, you need to load the appropriate genome package first (hg19 and hg38 are supported).

Below, we apply `make_matrix` to transform our example dataset (`example_dt`) into a data frame of trinucleotide mutations (`input_dt`). Each row in `input_dt` corresponds to a different patient and the values in the columns are the number of mutations for each trinucleotide mutation.

```{r}
# Load packages for make_matrix function
suppressPackageStartupMessages({
  library(BSgenome.Hsapiens.UCSC.hg19)
})
input_dt = make_matrix(example_dt)
print(input_dt)
```

# Getting your signature

To apply the supervised method on your data, run the `get_signature` function. The function has two parameters: an input data frame `dt` and the `factor` (e.g. `factor = "Smoking"`). `dt` is a data frame with the following columns:

* `sample_id` is an ID for each sample
* `age` is the age of the patient
* `IndVar` (indicator variable) is a logical indicator for whether they were exposed to the `factor` or not
* columns of counts for all 96 trinucleotide mutations

The process of converting a VCF file to this format is covered in [Preprocessing your data]. An example for `dt` is printed below.

```{r}
library(dplyr)

# Generate synthetic IndVar column
input_dt = input_dt %>%
  mutate(IndVar = c(1, 1, 1, 0, 0))
print(input_dt)
```


```{r}
out = get_signature(dt = input_dt, factor = "Smoking")
out
```

Once you have obtained the signature on your dataset, you can use the trained classifier (logistic regression) on a new dataset. The `predict_signature` function returns your data frame with additional columns for the feature counts in the signature and the classification score. For the purpose of illustration, we re-use the same dataset `input_dt` as our "new data" below. 

```{r}
newdata = predict_signature(out, newdata = input_dt, factor = "Smoking")
newdata %>% select(IndVar, F1, score)
```

```{r eval = F, include=F}
build_vignettes()
```


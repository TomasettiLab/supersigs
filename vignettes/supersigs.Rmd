---
title: "Using supersigs"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using supersigs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  comment = "#>"
)
```

```{r setup}
library(supersigs)
```

# Introduction

The `supersigs` package implements the supervised method proposed by *Afsari, et al.* to find signatures ("SuperSigs"). In this vignette, we cover how to preprocess your data and run the method in `supersigs`.

# Preprocessing your data

## Example data

The method uses single-base mutations in exomic data from cancer samples. Specifically, it requires data on every sample's mutations, the positions of those mutations, and the age of all patients. This data can be represented as a list of mutations (e.g. in a VCF file). Below is an example dataset (stored and accessible from the `supersigs` R package).

* `sample_id` is an ID for each sample
* `age` is the age of the patient
* `chromosome` and `position` is the position of the mutation
* `from` is the original nucleotide
* `to` is the mutated nucleotide 

```{r}
print(example_dt)
```

## Transform data

Once you've read in your data, you will need to transform it into a data frame of features that is readable by the `supersigs` package. This involves 2 steps:

1. First, we assume that mutations are the same regardless of the strand on which it occurred. For example, this means that C>A mutations are considered the same as G>T mutations. We will convert all G>T mutations to be denoted as C>A mutations using the named vector `transform_muts_vec`, which is stored and accessible from the `supersigs` R package.

2. Because the features used are built upon trinucleotide features (e.g. A[C>A]T), this will require matching your mutations to a reference genome to identify what the flanking bases of every mutation are. In our example below, we will use the `hg19` reference genome.

Both of these steps are done by the `make_matrix` function. Note that using the `make_matrix` function requires installing and loading a reference genome (`BSgenome.Hsapiens.UCSC.hg19` and `BSgenome.Hsapiens.UCSC.hg38` are supported).

```{r}
# Load packages for make_matrix function
suppressPackageStartupMessages({
  library(BSgenome.Hsapiens.UCSC.hg19)
})
```

We apply `make_matrix` to transform our example dataset (`example_dt`) into a data frame of trinucleotide mutations (`input_dt`), which is the format required by the `supersigs` R package. Each row in `input_dt` corresponds to a different patient and the values in the columns are the number of mutations for each trinucleotide mutation.

```{r}
input_dt = make_matrix(example_dt)
print(input_dt)
```

# Getting your signature

To apply the supervised method on your data, run the `get_signature` function. The function has two parameters: an input data frame `dt` and the `factor` (e.g. `factor = "Smoking"`). `dt` is a data frame with the following columns:

* `sample_id` is an ID for each sample
* `age` is the age of the patient
* `IndVar` (indicator variable) is a logical indicator for whether they were exposed to the `factor` or not
* columns of counts for all 96 trinucleotide mutations

The process of converting a VCF file to this format is covered in [Preprocessing your data]. An example for `dt` is printed below.

```{r}
# Generate synthetic IndVar column
input_dt$IndVar = c(1, 1, 1, 0, 0)
print(input_dt)
```

Once you have the correct data format, apply `get_signature` to the dataset to get your `SuperSig`. This is an S4 object containing four slots:

* `Signature` is the signature, represented as their differences in mean rates (or counts if the factor is "age") between the two groups (exposed versus unexposed)
* `Features` is the list of features that comprise the signature and their representation in terms of the fundamental (trinucleotide) mutations
* `AUC` is the apparent AUC of the model (i.e. not cross-validated)
* `Model` is the list of a glm class for the trained logistic regression model

```{r}
out = get_signature(dt = input_dt, factor = "Smoking")
out
```

# Using your signature

To apply the `SuperSig` to a new dataset, you can use the `predict_signature` function. This function returns the new dataset with columns for feature counts for the signature and a score column for the predicted classification score.

```{r}
newdata = predict_signature(out, newdata = input_dt, factor = "Smoking")

suppressPackageStartupMessages({
  library(dplyr)
})
newdata %>%
  select(IndVar, F1, score)
```

```{r eval = F, include=F}
build_vignettes()
```

